1. [目次へ](index.md)


# ディスパッチャとタスクスケジューリング
`ディスパッチ`：タスクにCPUの使用権が割り当てられること  
`タスクスケジューリング`：タスクの実行順序

|タスクスケジューリング方式|概要|
|---|---|
|到着順方式|実行可能になったタスク順に、CPUの使用権を割り当てる方式です。タスクに優先度の概念がないので、実行の途中でCPU使用権が奪われることはありません（これを`ノンプリエンプション`といいます）。|
|優先度順方式|タスクにそれぞれ優先度を設定し、その優先度が高いものから順に実行していく方式です。実行中のタスクよりも優先度の高いものが待ち行列に追加されると、実行の途中でCPU使用権が奪われます（これを`プリエンプション`といいます|
|動的優先順位方式|基本的な動きは優先順位方式と同じですが、その優先度を徐々に上げていく（`エージング`）という点が異なる方式です。これによってスタベーションの発生を回避します。|
|ラウンドロビン方式|CPUの使用権を、一定時間（`タイムクォンタム`）ごとに切り替える方式です。<br>実行可能状態になった順番でタスクにCPU使用権が与えられますが、規定時間内に処理が終わらなかった場合は、次のタスクに使用権が与えられ、実行中だったタスクは待ち行列の最後に回されます。|
|多重待ち行列方式|ラウンドロビン方式に優先順位を加味させた方式です。<br>各優先度ごとに待ち行列を持ち、一定時間で処理が終了しなかった場合は、そのタスクの優先度を下げて、下位の待ち行列末尾へと回します。|
|処理時間順方式|タスクの処理時間が、より短いものから順に処理をしていく方式です。実際には実行前に処理時間を予測するのは困難であるため、実装は難しい物があります。<br>`SPT(Shortest Processing Time First)`|
|イベントドリブン方式|マウスによる入力など、環境の変化をタスク切り換えのきっかけ（`トリガ`）としてCPUの使用権を切り替える方式です。GUI操作のOSではおなじみの方式でもあります。|

実行中のタスクが、別のタスクへとCPUの使用権を切り替えられることを`コンテキスト切替え`と呼びます。このコンテキスト切替えが強制的に発生する方式を`プリエンプティブ方式`と言います（その逆が`ノンプリエンプティブ方式`）。


# タスクの排他制御/同期処理
タスクはその生成時に、OSから独立した記憶領域を割り当てられて動作します。  
その記憶領域には、プログラム自身を格納するための領域の他に、タスク内で用いられる領域がある。  

・記憶領域の種類  
`スタック`：タスク内で用いられる変数や関数呼び出しに必要な情報などを格納する記憶領域  
`ヒープ`：メモリを確保する命令を用いることで都度必要に応じて動的に確保する記憶領域  
このOSから独立した記憶領域内で処理を行う分には、複数のタスクが動いていても問題は起きません。  
しかし、ファイルや共有メモリといった、どのタスクからもアクセスできるリソースの場合は、タスク同士で処理がぶつかってしまう恐れがあります。

# セマフォ
一連の処理の中で、2つ以上のタスクが同時に資源（リソース）を奪い合うことで処理に不整合が生じる箇所。これを`クリティカルセクション`と呼びます。  
このクリティカルセクションに入る前後で、問題が生じないように行う処理が排他制御です。  
`セマフォ`というのは、Dijkstra（ダイクストラ）によって考案された、排他制御のためのメカニズムです。  

セマフォの基本概念は単純です。  
`セマフォ変数`に資源の共有状態を記録して、空いていなければ待ち行列に並ぶ。  
セマフォ変数を自由に書き換えることができてしまうと、排他制御が成り立たないので専用命令を使用します。  
|命令|概要|
|---|---|
|P操作<br>資源をロックする|・セマフォ変数Sの中身が1以上の時、Sを`1減算してタスクの実行を継続`します。<br>・セマフォ変数Sの中身が0の時、実行を中断して待ち行列に並びます（ロック済みのためクリティカルセクションに入れない）。|
|V操作<br>資源のロックをアンロックする|・セマフォ変数Sの中身を`1加算`します。<br>・`待ち行列の先頭タスクを実行可能状態に遷移`させます（そのタスクは、再びP操作を試みることが可能になる）。|
セマフォ変数の中身が任意個であるものを`ゼネラルセマフォ`（計数セマフォ）、0と1に限定されたものを`バイナリセマフォ`と呼びます。  

# デッドロック
排他制御において、複数の資源をそれぞれのタスクが無秩序にロックしていくと、互いに相手のロックしている資源の解除待ちに入ってしまし、処理が進行しなくなるという現象が起こりえます。  
これを`デッドロック`と言います。

これを避けるためには、`資源のロック順序を両方のタスクで同じに揃えること`です。順序がおなじであれば、順序資源の解放に応じて次のタスクがロックできるようになるので、この問題は生じません。

# 同期制御とイベントフラグ
タスクは必ずしもそれ単独で動作するばかりではありません。タスク同士が互いに依存関係を持ち、一方の処理を待って他方が実行を再開するといった協調動作も行われます。  
このような、タスク同士を強調させるために実行タイミングを図る仕組みを、`同期制御`と呼びます。

# タスク間の通信
タスク間の通信に用いられる代表的な手段としては、次のようなものがあります。
|通信手段|詳細|
|---|---|
|共有メモリ(Shared Memory)|メモリ上、複数のタスクから利用できる記憶領域を設けてデータ交換を行います。|
|メッセージキュー|キューというのは、簡単に言えば待ち行列のことです。メッセージ処理用のキューにタスクからのデータをメッセージとして送信し、受信側はこのキューを介してデータを受け取ります。|
|パイプ|仮想的なパイプを通してデータをやり取りする仕組み。あるタスクの出力を、もう一方のタスクに入力として接続し、データを転送します。

# 実記憶管理
限られた主記憶空間を、効率良く使えるようプログラムを割り当てるのが、`実記憶管理`の役割です。

# 固定区画方式
`固定区画方式`は、主記憶に固定長の区画（`パーティション`）を設けて、そこにプログラムを読み込む管理方式です。  
全体を単一の区画とする`単一区画方式`と、複数の区画に分ける`多重区画方式`があります。  

単純な仕組みなので記憶管理は簡単で済みますが、プログラムを読み込んだ後、区画内に生じた余りスペースは使用することができず、区画サイズ以上のプログラムを読み込むこともできません。  
したがって、主記憶の利用効率は、あまりよくありません。  

# 可変区画方式
プログラムをロードするタイミングで必要なサイズに区切る管理方式が`可変区画方式`です。  
この方式では、プログラムが必要とする大きさで区画を作り、そこにプログラムをロードします。  
区画内に余剰スペースが生じないため、固定区画方式よりも主記憶の利用は効率よくなります。  

# フラグメンテーションとメモリコンパクション
可変区画方式だと、主記憶上にプログラムを隙間なく詰め込んで実行することができるが、必ずしも詰め込んだ順番にプログラムが終了するとは限りません。  
そうすると、主記憶の空き容量自体がプログラムの実行に足りるサイズであったとしても、それを連続した状態で確保することができません。  
この現象を`フラグメンテーション（断片化）`と呼びます。  

フラグメンテーションを解消するためには、ロードされているプログラムを再配置することによって、細切れ状態にある空き領域を、連続したひとつの領域にしてやる必要があります。  
この操作を`メモリコンパクション`、もしくは`ガベージコレクション`と呼びます。  

# オーバーレイ方式
プログラムを`セグメント`という単位に分割しておいて、その時に必要なセグメントだけを主記憶上にロードして実行します。

# スワッピング方式
マルチプログラミング環境では、優先度の高いプログラムによる割り込みなどが発生した場合、現在実行中のものをいったん中断させて切り替えを行う。  

このような時は、優先度の低いプログラムが使っていた主記憶領域の内容を、いったん補助記憶装置に丸ごと退避させることで空き領域を作ります。

退避させたプログラムに再びCPUの使用権が与えられる時は、退避させた内容を補助記憶装置から主記憶へとロードし直して、中断箇所から再開します。

`スワップアウト`：プログラムを補助記憶装置に退避させて空き領域を作る  
`スワップイン`：退避させたプログラムを再ロードする  

スワップアウトとスワップインをあわせた、このような処理のことを`スワッピング`と呼びます。  
スワッピングが発生すると、主記憶の代用として低速な補助記憶装置へのアクセスを行うことになるので、処理速度が極端に低下します。  

# 再配置可能プログラムとプログラムの4つの性質

`再配置可能プログラム`なら、主記憶のどこに配置しても問題なく実行できます。  
|性質|詳細|
|---|---|
|再配置可能<br>リロケータブル|主記憶上の、どこに配置しても実行することができるという性質を、`再配置可能（リロケータブル）`と言います。|
|再使用可能<br>リユーザブル|主記憶上にロードされて処理を終えたプログラムを、再ロードすることなく、繰り返し実行できる（そして毎回正しい結果を得ることができる）という性質を`再使用可能（リユーザブル）`と言います|
|再入可能<br>リエントラント|再ロードすることなく繰り返し実行できる再使用可能プログラムにおいて、複数のタスクから呼び出しても、互いに干渉することなく同時実行できるという性質を`再入可能（リエントラント）`と言います。|
|再帰的<br>リカーシブ|実行中に、自分自身を呼び出すことができるという性質を`再帰的（リカーシブ）`と言います。|
