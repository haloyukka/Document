1. [目次へ](index.md)


# ディスパッチャとタスクスケジューリング
`ディスパッチ`：タスクにCPUの使用権が割り当てられること  
`タスクスケジューリング`：タスクの実行順序

|タスクスケジューリング方式|概要|
|---|---|
|到着順方式|実行可能になったタスク順に、CPUの使用権を割り当てる方式です。タスクに優先度の概念がないので、実行の途中でCPU使用権が奪われることはありません（これを`ノンプリエンプション`といいます）。|
|優先度順方式|タスクにそれぞれ優先度を設定し、その優先度が高いものから順に実行していく方式です。実行中のタスクよりも優先度の高いものが待ち行列に追加されると、実行の途中でCPU使用権が奪われます（これを`プリエンプション`といいます|
|動的優先順位方式|基本的な動きは優先順位方式と同じですが、その優先度を徐々に上げていく（`エージング`）という点が異なる方式です。これによってスタベーションの発生を回避します。|
|ラウンドロビン方式|CPUの使用権を、一定時間（`タイムクォンタム`）ごとに切り替える方式です。<br>実行可能状態になった順番でタスクにCPU使用権が与えられますが、規定時間内に処理が終わらなかった場合は、次のタスクに使用権が与えられ、実行中だったタスクは待ち行列の最後に回されます。|
|多重待ち行列方式|ラウンドロビン方式に優先順位を加味させた方式です。<br>各優先度ごとに待ち行列を持ち、一定時間で処理が終了しなかった場合は、そのタスクの優先度を下げて、下位の待ち行列末尾へと回します。|
|処理時間順方式|タスクの処理時間が、より短いものから順に処理をしていく方式です。実際には実行前に処理時間を予測するのは困難であるため、実装は難しい物があります。<br>`SPT(Shortest Processing Time First)`|
|イベントドリブン方式|マウスによる入力など、環境の変化をタスク切り換えのきっかけ（`トリガ`）としてCPUの使用権を切り替える方式です。GUI操作のOSではおなじみの方式でもあります。|

実行中のタスクが、別のタスクへとCPUの使用権を切り替えられることを`コンテキスト切替え`と呼びます。このコンテキスト切替えが強制的に発生する方式を`プリエンプティブ方式`と言います（その逆が`ノンプリエンプティブ方式`）。


# タスクの排他制御/同期処理
タスクはその生成時に、OSから独立した記憶領域を割り当てられて動作します。  
その記憶領域には、プログラム自身を格納するための領域の他に、タスク内で用いられる領域がある。  

・記憶領域の種類  
`スタック`：タスク内で用いられる変数や関数呼び出しに必要な情報などを格納する記憶領域  
`ヒープ`：メモリを確保する命令を用いることで都度必要に応じて動的に確保する記憶領域  
このOSから独立した記憶領域内で処理を行う分には、複数のタスクが動いていても問題は起きません。  
しかし、ファイルや共有メモリといった、どのタスクからもアクセスできるリソースの場合は、タスク同士で処理がぶつかってしまう恐れがあります。

# セマフォ
一連の処理の中で、2つ以上のタスクが同時に資源（リソース）を奪い合うことで処理に不整合が生じる箇所。これを`クリティカルセクション`と呼びます。  
このクリティカルセクションに入る前後で、問題が生じないように行う処理が排他制御です。  
`セマフォ`というのは、Dijkstra（ダイクストラ）によって考案された、排他制御のためのメカニズムです。  

セマフォの基本概念は単純です。  
`セマフォ変数`に資源の共有状態を記録して、空いていなければ待ち行列に並ぶ。  
セマフォ変数を自由に書き換えることができてしまうと、排他制御が成り立たないので専用命令を使用します。  
|命令|概要|
|---|---|
|P操作<br>資源をロックする|・セマフォ変数Sの中身が1以上の時、Sを`1減算してタスクの実行を継続`します。<br>・セマフォ変数Sの中身が0の時、実行を中断して待ち行列に並びます（ロック済みのためクリティカルセクションに入れない）。|
|V操作<br>資源のロックをアンロックする|・セマフォ変数Sの中身を`1加算`します。<br>・`待ち行列の先頭タスクを実行可能状態に遷移`させます（そのタスクは、再びP操作を試みることが可能になる）。|
セマフォ変数の中身が任意個であるものを`ゼネラルセマフォ`（計数セマフォ）、0と1に限定されたものを`バイナリセマフォ`と呼びます。  

# デッドロック
排他制御において、複数の資源をそれぞれのタスクが無秩序にロックしていくと、互いに相手のロックしている資源の解除待ちに入ってしまし、処理が進行しなくなるという現象が起こりえます。  
これを`デッドロック`と言います。

これを避けるためには、`資源のロック順序を両方のタスクで同じに揃えること`です。順序がおなじであれば、順序資源の解放に応じて次のタスクがロックできるようになるので、この問題は生じません。

# 同期制御とイベントフラグ
タスクは必ずしもそれ単独で動作するばかりではありません。タスク同士が互いに依存関係を持ち、一方の処理を待って他方が実行を再開するといった協調動作も行われます。  
このような、タスク同士を強調させるために実行タイミングを図る仕組みを、`同期制御`と呼びます。

# タスク間の通信
タスク間の通信に用いられる代表的な手段としては、次のようなものがあります。
|通信手段|詳細|
|---|---|
|共有メモリ(Shared Memory)|メモリ上、複数のタスクから利用できる記憶領域を設けてデータ交換を行います。|
|メッセージキュー|キューというのは、簡単に言えば待ち行列のことです。メッセージ処理用のキューにタスクからのデータをメッセージとして送信し、受信側はこのキューを介してデータを受け取ります。|
|パイプ|仮想的なパイプを通してデータをやり取りする仕組み。あるタスクの出力を、もう一方のタスクに入力として接続し、データを転送します。

# 実記憶管理
限られた主記憶空間を、効率良く使えるようプログラムを割り当てるのが、`実記憶管理`の役割です。

# 固定区画方式
`固定区画方式`は、主記憶に固定長の区画（`パーティション`）を設けて、そこにプログラムを読み込む管理方式です。  
全体を単一の区画とする`単一区画方式`と、複数の区画に分ける`多重区画方式`があります。  

単純な仕組みなので記憶管理は簡単で済みますが、プログラムを読み込んだ後、区画内に生じた余りスペースは使用することができず、区画サイズ以上のプログラムを読み込むこともできません。  
したがって、主記憶の利用効率は、あまりよくありません。  

# 可変区画方式
プログラムをロードするタイミングで必要なサイズに区切る管理方式が`可変区画方式`です。  
この方式では、プログラムが必要とする大きさで区画を作り、そこにプログラムをロードします。  
区画内に余剰スペースが生じないため、固定区画方式よりも主記憶の利用は効率よくなります。  

# フラグメンテーションとメモリコンパクション
可変区画方式だと、主記憶上にプログラムを隙間なく詰め込んで実行することができるが、必ずしも詰め込んだ順番にプログラムが終了するとは限りません。  
そうすると、主記憶の空き容量自体がプログラムの実行に足りるサイズであったとしても、それを連続した状態で確保することができません。  
この現象を`フラグメンテーション（断片化）`と呼びます。  

フラグメンテーションを解消するためには、ロードされているプログラムを再配置することによって、細切れ状態にある空き領域を、連続したひとつの領域にしてやる必要があります。  
この操作を`メモリコンパクション`、もしくは`ガベージコレクション`と呼びます。  

# オーバーレイ方式
プログラムを`セグメント`という単位に分割しておいて、その時に必要なセグメントだけを主記憶上にロードして実行します。

# スワッピング方式
マルチプログラミング環境では、優先度の高いプログラムによる割り込みなどが発生した場合、現在実行中のものをいったん中断させて切り替えを行う。  

このような時は、優先度の低いプログラムが使っていた主記憶領域の内容を、いったん補助記憶装置に丸ごと退避させることで空き領域を作ります。

退避させたプログラムに再びCPUの使用権が与えられる時は、退避させた内容を補助記憶装置から主記憶へとロードし直して、中断箇所から再開します。

`スワップアウト`：プログラムを補助記憶装置に退避させて空き領域を作る  
`スワップイン`：退避させたプログラムを再ロードする  

スワップアウトとスワップインをあわせた、このような処理のことを`スワッピング`と呼びます。  
スワッピングが発生すると、主記憶の代用として低速な補助記憶装置へのアクセスを行うことになるので、処理速度が極端に低下します。  

# 再配置可能プログラムとプログラムの4つの性質

`再配置可能プログラム`なら、主記憶のどこに配置しても問題なく実行できます。  
|性質|詳細|
|---|---|
|再配置可能<br>リロケータブル|主記憶上の、どこに配置しても実行することができるという性質を、`再配置可能（リロケータブル）`と言います。|
|再使用可能<br>リユーザブル|主記憶上にロードされて処理を終えたプログラムを、再ロードすることなく、繰り返し実行できる（そして毎回正しい結果を得ることができる）という性質を`再使用可能（リユーザブル）`と言います|
|再入可能<br>リエントラント|再ロードすることなく繰り返し実行できる再使用可能プログラムにおいて、複数のタスクから呼び出しても、互いに干渉することなく同時実行できるという性質を`再入可能（リエントラント）`と言います。|
|再帰的<br>リカーシブ|実行中に、自分自身を呼び出すことができるという性質を`再帰的（リカーシブ）`と言います。|

# 仮想記憶管理
仮想記憶は、主記憶や補助記憶の存在を隠蔽することで、広大なメモリ空間を自由に扱えるようにするものです。  
仮想記憶とは「実記憶などの物理的な存在を隠蔽して、仮想空間にマッピングしてみえる」ための技術です。  
この時、仮想アドレスから実アドレスへの変換処理は、メモリ変換ユニット（MMU:Memory Management Unit）というハードウェアが担当します。  
この仕組みを、`動的アドレス変換機構（DAT:Dynamic Address Translator）`と呼びます。  

実記憶の容量よりも大きなサイズを提供する仕組み  
仮想記憶では、補助記憶装置もメモリーの一部と見なすことで、実記憶の容量よりも大きなサイズの記憶空間を、提供できる仕組みになっているのです。  
仮想記憶=`「主記憶として使うことのできる見かけ上の要領を拡大させる仕組み」`という使われ方が良く主題されます。  

# ページング方式
仮想記憶の実装方式には、仮想アドレス空間を`固定長の領域に区切って管理するページング方式と、可変長の領域に区切って管理するセグメント方式`の2つがあります。  

ページング方式では、プログラムを「`ページ`」という単位に分割して管理します。  
仮想記憶と実記憶との対応付は、`ページテーブル`という表によって管理されます。この表によって、仮想ページ番号が実記憶上のどのページと結びついているかが確認できるわけです。  
目的のページが実記憶上にないと判明したら、補助記憶から実記憶へとそのページが読み込まれます。  
<br>
ページテーブルを用いて、仮想記憶上のいちを指し示す仮想アドレスから、どのように実アドレスが導き出されるかの例  


（仮想アドレス）
|ページ番号|ページ内変位（ページ内相対位置）|
|---|---|
|0100|000000001100|

上記のような仮想アドレスが与えられた場合、まず先頭数ビット（この例の場合は4ビット）を見て仮想ページ番号を取得し、ページテーブルの中身を検索します。  
ここで得られたアドレスは、あくまでも実記憶上にあるページ枠の先頭アドレスでしかありません。  
したがって、仮想アドレスのページ内変位部をこのアドレスに加算します。  
これによって実アドレスが得られます。  
<br>
ページテーブルを確認して「実記憶に存在しない」となった場合は、実記憶へのページ読み込みが発生します。  
補助記憶から実記憶へのページ読み込みを`ページイン`と言います。  
ページインをしようとしたら、すでに実記憶がいっぱいでしたという場合、いずれかのページを補助記憶に追い出して空きを作らなければいけません。  
実記憶から補助記憶へとページを追い出すことを`ページアウト`といいます。
<br>
実記憶の容量が少ないと、ページの置換えを必要とする頻度が高くなり、システムの処理を効率が極端に低下することがあります。  
この現象を`スラッシング`と呼びます。  

# ページの置き換えアルゴリズム
ページアウトする対象を決定するための置き換えアルゴリズム
|アルゴリズム|詳細|
|---|---|
|FIFO(First In First Out)方式|最初に(First In)ページインしたページを、追い出し対象にします。|
|LIFO(Last In First Out)方式|最後に(Last In)ページインしたページを、追い出し対象にします。|
|LRU(Least Recently Used)方式|もっとも長い間参照されてないページを、追い出し対象にします。|
|LFU(Least Frequently Used)方式|もっとも参照回数の少ないページを、追い出し対象にします。|

# ページングとスワッピング
スワッピング：`プロセス単位`で領域の出し入れを行います。  
ページング：`ページ単位`で領域の出し入れを行います。

# UNIX系OS
UNIXは、マルチユーザ・マルチプロセス環境を重視したワークステーション用のOSです。  

# ファイルシステムの特徴
UNIXでは、ファイルを`通常ファイル・ディレクトリファイル・特殊ファイル`という3つに分類しています。
|ファイル|詳細|
|---|---|
|通常ファイル|テキストファイルや画像ファイルといったデータを格納するファイルや、プログラムファイルなど。一般に「ファイル」と言われるもの全般です。|
|ディレクトリファイル|ファイルをグループ化して整理するために、ファイルを束ねる容れ物として利用するのがディレクトリ。この中にはファイルだけでなく、ディレクトリも含むことができ、これによって全体を階層構造であらわしています。実際にはこのディレクトリもファイルの一種で、ディレクトリ内に含むファイル名と、その実体の場所を格納しています。|
|特殊ファイル|磁気ディスクやプリンタといった入出力装置をファイルとしてあらわしたもの。UNIXでは周辺装置を抽象化することで、それらの入出力も、ファイルと同じ手続きで行うことができます。|

HDDなどの磁気ディスクも、UNIX環境下では特殊ファイルのひとつでしかありません。  
したがって、ファイルシステムの階層構造をあらわす時、最上位は"/"（ルートディレクトリ）ただひとつです。すべてのファイルはここを起点にたどることができます。  
各装置は階層構造の中でどの位置に接続するかをシステムに認識させることで使えるようになります。この接続動作を`マウント`と呼びます。  

# 標準ストリーム
プロセスと実行環境（端末）の間で、あらかじめ定められている入出力チャンネルのことを標準ストリームと言います。  
UNIXにおいては、`標準入力`・`標準出力`・`標準エラー`出力という3つの入出力が用意されています。  
<br>
シェル上で実行するコマンドは「コマンド」という特殊な呪文ではありません。ただの小さなプログラムです。  
では、3つの入出力とは何でしょう。UNIXでは次の装置とそれぞれ結びついています。  
入力が必要であればキーボードから受け付けて（標準入力）、処理の結果はディスプレイに出力（標準出力）、何かエラーが起きた場合もディスプレイに出力（標準エラー出力）という具合に使えるようになっているわけですね。  

# リダイレクションとパイプ
## リダイレクション
コマンドの標準入出力を別のものに切り替える機能です。  
これにより、実行結果を画面に出す代わりにファイルへと出力したり、キーボードではなくファイルの中身を入力として渡したりすることができます。  
たとえば`ls > file`とコマンド入力すると、その実行結果を納めたfileが出来上がります。  
## パイプ
あるコマンドの標準出力を、続くコマンドの標準入力として受け渡す機能です。  
複数のコマンド間でデータを引き継いで連続処理を行うことができます。  
たとえば、`ls | grep test`とコマンド入力すると、lsによって取得されたファイル一覧から、grep（検索するコマンド）によって「test」という文字列を含むファイル名だけが抽出されて画面に表示されます。
